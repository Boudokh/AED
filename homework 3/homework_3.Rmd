---
title: 'Homework II: SVD analysis & Life Tables'
subtitle: 'Deadline: 2020-05-20'
author: "Inès Dardouri, Mohamed Boudokhane and Lycia Fezzoua"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: yes
    keep_md: yes
    number_sections: yes
    toc: yes
  html_notebook:
    code_folding: none
    number_sections: yes
    toc: yes
params:
    dirpath: '../LIFE_TABLES/lt_'
    country_code: 'fr_t'
    country: 'France'
    timecourse: 1945:2015
---


---

# Objectives

This notebook aims at

  - working with **tables** (`data.frames`, `tibbles`, `data.tables`, ...) using `dplyr` or any other query language (as provided for example by `data.table`)
  - visualizing demographic data as provided by [Human Mortality Database organization](https://www.mortality.org).
  - using PCA and other matrix oriented methods (CCA) to explore a multivariate datasets (lifetables may be considered as multivariate datasets)

# Life tables data (ETL)

Life data tables are downloaded from [https://www.mortality.org](https://www.mortality.org).

See also [https://www.lifetable.de](https://www.lifetable.de).

If you install and load package [https://cran.r-project.org/web/packages/demography/index.html](https://cran.r-project.org/web/packages/demography/index.html), you will also find life data tables.

We investigate life tables describing countries from Western Europe (France, Great Britain --actually England and Wales--, Italy, the Netherlands, Spain, and Sweden) and the United States.

We load the one-year lifetables for female, male and whole population for the different countries.

```{r, echo=FALSE, eval=FALSE}
# for debugging
# params should be initialized from YAML header
params<- list(
    timecourse= 1945:2015,
    dirpath= 'LIFE_TABLES/lt_',
    country_code= 'fr_c',
    country= 'France')
```

```{r, echo=FALSE}
timecourse <- eval(rlang::parse_expr(params$timecourse))
```

```{r tidyverse, echo=FALSE, message=FALSE, warning=FALSE}
pacman::p_load(tidyverse)
pacman::p_load(plotly)
pacman::p_load(foreach)
pacman::p_load(iterators)
pacman::p_load(DT)
pacman::p_load(ade4)
pacman::p_load(FactoMineR)
pacman::p_load(factoextra)
pacman::p_load(FactoInvestigate)
pacman::p_load(ggfortify)

old_theme <-theme_set(theme_dark(base_size=9,
                                 base_family = "Helvetica"))

knitr::opts_chunk$set(eval=FALSE,
  echo=FALSE,
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  autodep = TRUE,
  tidy = FALSE)

```


```{r, echo=FALSE}
country_code <- list(#fr_t='FRATNP',
                     fr_c='FRACNP',
                     be='BEL',
                     gb_t='GBRTENW',
                     gb_c='GBRCENW',
                     nl='NLD',
                     it='ITA',
                     swe='SWE',
                     sp='ESP',
                     us='USA')

countries <- c( 'fr_c', 'gb_t',  'nl', 'it', 'sp', 'swe', 'us')  

country_names <- list(fr_t='France',     # total population
                     fr_c='France',      # civilian population
                     be='Belgium',
                     gb_t='England & Wales',    # total population
                     gb_c='England & Wales',    # civilian population
                     nl='Netherlands',
                     it='Italy',
                     swe='Sweden',
                     sp='Spain',
                     us='USA')

gender_names <- list('b'='Both',
                     'f'='Female',
                     'm'='Male')

 
```


```{r load_tabble, warning=FALSE, message=FALSE}

dirpath <- 'LIFE_TABLES/lt_'    
suffix <- 'ltper_1x1.txt'
mid <- 'ltper_1x1/'

foreach(country=iter(countries), .combine = c) %do% {
  purrr::map2_chr(.x = c("both/b", "female/f", "male/m"),
                  .y = c("b", "f", "m"),
                  .f = ~ stringr::str_c(dirpath,
                                  .x ,
                                  mid,
                                  country_code[[country]],
                                  ".",
                                  .y,
                                  suffix))
  }  -> file_paths

df_names <- as.character(outer(c("b", "f", "m"),
                  countries,
                  FUN = function(s, c) stringr::str_c("data", s, c, sep="_")))

out <- purrr::map(file_paths,
                  ~ readr::read_delim(., delim = " ",
                                      skip = 2,
                                      col_names = TRUE))


names(out) <-  df_names

purrr::map2(.x = out,
            .y=stringr::str_split(df_names, pattern = 'data_[m,f,b]_', simplify = TRUE)[,2],
            ~ mutate(.x, Country=country_names[[.y]])) -> out

purrr::map2(.x = out,
            .y =stringr::str_split(df_names, pattern = '_', simplify = TRUE)[,2],
            ~ mutate(.x, Gender=gender_names[[.y]])) -> out


list2env(x = out, envir = environment())

```
```{r inspect_tables}
out['data_b_nl'] %>%
  glimpse()
```


Check on [http://www.mortality.org](http://www.mortality.org) the meaning of the different columns:

`mx`: Central death rate between ages x and x+n where n=1, 4, 5, or ∞ (open age interval)

`qx`: Probability of death between ages x and x+n

`ax`: Average length of survival between ages x and x+n for persons dying in the interval

`lx`: Number of survivors at exact age x, assuming l(0) = 100,000

`dx`: Number of deaths between ages x and x+n

`ex`:: Life expectancy at exact age x (in years)


Document [Tables de mortalité françaises pour les XIXe et XXe siècles et projections pour le XXIe siècle](https://www.lifetable.de/data/FRA/FRA000018061997CY1.pdf) contains
detailed information on the construction of Life Tables for France.
Two kinds of Life Tables can be distinguished: *Table du moment* which
contain for each calendar year, the mortality risks at different ages for that very year; and *Tables de génération* which contain for a given birthyear, the   mortality risks
at which an individual born during that year has been exposed. The life tables investigated in this homework are *Table du moment*. According to the document by Vallin and Meslé, building the life tables  required decisions and doctoring.

See (among other things)

- p. 19 Abrupt changes in mortality quotients at some ages for a given calendar year
- Estimating mortality quotients at great age.

Have a look at [Lexis diagram](https://en.wikipedia.org/wiki/Lexis_diagram).

Some columns need retyping:

- `Year`: should be integer
- `Age`:  needs some cleaning, after cleaning it should be typed as integer
- `Lx`: should be integer
- `Tx`: should be integer
- Other columns should be considered as floating point numbers (`numeric`)

```{r}
retype <- function(data){
  require(magrittr)

  data %>%
    dplyr::rename_all(stringr::str_trim) ->
    data

  double_cols <-  c("mx", "qx", "ax", "ex")
  integer_cols <- setdiff(names(data), c(double_cols, "Country", "Gender"))

  data %>%
    dplyr::mutate_at(double_cols, as.numeric) %>%
    dplyr::mutate_at(integer_cols, as.integer) %>%
    dplyr::mutate_at(vars(Country,Gender), forcats::as_factor) %>%
    tidyr::drop_na(Age) -> data


  data
}

out %>%
  purrr::map(retype) -> out


list2env(x = out, envir = environment())

```

```{r}
count_na <- function(data){
  data %>%
    dplyr::summarise_all(.funs = ~sum(is.na(.)))-> res
  res
}

# for (data_f in l_f)
#   retype(data_f) -> data_f
# for (data_m in l_m)
#   retype(data_m) -> data_m
# for (data_b in l_b)
#   retype(data_b) -> data_b
#   glimpse(data_b)
#   sapply(data_b, class)

data_b_nl
```


---

- [ ] After ETL processing, you obtain a universal table encompassing
all data available  in the files located in `LIFE_TABLES` directory.
Henceforth, the universal table is named `life_table`, its schema should be
the following.

| Column Name | Column Type |
|:------------|:------------|
|  Year       | integer     |
|  Age        | integer     |
|  mx         | double      |
|  qx         | double      |
|  ax         | double      |
|  lx         | integer     |
|  dx         | integer     |
|  Lx         | integer     |
|  Tx         | integer     |
|  ex         | double      |
|  Country    | factor      |
|  Gender     | factor      |

Coercion introduces a subtantial number of NA  warnings.
Preliminary inspection of the data suggests that coercion problems
orginate from column `Age`: `110+` cannot be coerced to an integer value.
Discard corresponding rows using `tidyr::drop_na(Age)`.

```{r}
out %>%
  purrr::map(~ sum(is.na(.))) %>%
  as.data.frame() %>%
  pivot_longer(cols= names(.), names_to="Data frame", values_to="# NAs")

data_b_nl  %>%
  summarise_all(~ sum(is.na(.)))

# typeof(data_b_nl)
# typeof(out['data_b_nl'])

```

# Western countries in 1948

- [ ] Plot the central death rates of all Countries at all ages for year 1948.

Petite explication

```{r}
pacman::p_load(viridis)
library(plyr)

p <- out %>%
  ldply( data.frame) %>%
  filter(Year == '1948') %>%
  ggplot(mapping=aes(x=Age, y=mx)) +
  geom_smooth(method="loess", se=FALSE, span=.5,aes(colour = forcats::as_factor(Country)), size = .2) +
  scale_y_log10() +
  xlab("Age")+
  ylab("Death rates") +
  labs(colour = "Countries") +
  ggtitle("Central death rates at all ages for year 1948") +
  theme_bw()

print(p)
```

- [ ] Comment.

We notice that the death rates for new borns are much higher for Italy and Spain than for the rest of the european countries and for the USA. This difference is still noticable for infant mortality. But for the adults, the death rates are pretty much the same for all countries. The difference for young people's mortality could be explained by the different economic and health conditions at that time between the different countries. 
  
- [ ] Plot ratios between central death rates in European countries and
central death rates in the USA in 1948.

```{r}

```

- [ ] Comment

# Death rates evolution since WW II

- [ ] Plot mortality quotients (column `mx`) for
both genders as a function of `Age` for  years `1946, 1956, ...` up to `2016` .
Use aesthetics to distinguish years.

```{r}

after_ww_II <- seq(1946,2016, by = 10)

pacman::p_load(viridis)
library(plyr)

p <- out %>%
  ldply( data.frame) %>%
  filter(Year %in% after_ww_II, Gender %in% c('Male','Female')) %>%
  ggplot(mapping=aes(x=Age, y=mx)) +
  geom_smooth(method="loess", se=FALSE, span=.5,aes(colour = forcats::as_factor(Year)), size = .2) +
  scale_y_log10() +
  xlab("Age")+
  ylab("Mortality quotients") +
  labs(colour = "Years") +
  facet_wrap(vars(Gender)) +
  ggtitle("Mortality quotients for both genders as a function of Age since after WWII") +
  theme_bw()

print(p)


```



- [ ] Facet by `Gender`  and `Country`

```{r}
library(plotly)
p %+%
  facet_grid(vars(Gender),vars(Country)) +
  ylab("Mortality quotients") 


```


- Comment concerning the plot below:
We notice that the mortality quotients of young people in 1946 is smaller in the USA than in all the European countries.
This is certainly due to the fact that the USA didn't suffer a lot from human loss during the WWII, unlike the European countries.



- [ ] Write a function `ratio_mortality_rates` with signature
`function(df, reference_year=1946, target_years=seq(1946, 2016, 10))`
that takes as input:

  - a dataframe with the same schema as `life_table`,
  - a reference year `ref_year` and
  - a sequence of years `target_years`

and that returns a dataframe with schema:


| Column Name | Column Type |
|:------------|:------------|
|  Year       | integer     |
|  Age        | integer     |
|  mx         | double      |
|  mx.ref_year| double      |
|  Country    | factor      |
|  Gender     | factor      |

where `(Country, Year, Age, Gender)` serves as a _primary key_,
`mx` denotes the central death rate at `Age` for `Year` and `Gender` in `Country`
whereas `mx_ref_year` denotes central death rate at `Age` for argument `reference_year`
in `Country` for `Gender`.


```{r}
ratio_mortality_rates <- function(df,
                                  reference_year=1946,
                                  target_years=seq(1946, 2016, 10)){
  
  dplyr::filter(df, Year %in% target_years) %>%
  dplyr::inner_join(y=df[df$Year==1946, c("Age", "mx")], by=c("Age")) %>%
  dplyr::filter(Age <90) -> df
  df <- select (df,-c(qx,ax,lx,dx,Lx,Tx,ex ))
  df
}

ratio_mortality_rates(data_b_nl)
```


- [ ] Draw plots displaying the ratio  $m_{x,t}/m_{x, 1946}$ for ages $x \in 1, \ldots, 90$
and year $t$ for $t \in 1946, \ldots, 2016$ where $m_{x,t}$ is the central death rate
at age $x$ during year  $t$.

```{r}
q <- dplyr::filter(ratio_mortality_rates(data_b_nl), FALSE) %>%
  ggplot(aes(x=Age, y=mx.x/mx.y)) +
  geom_smooth(method="loess",
              se= FALSE,
              size =.5,
              span= .2) +
  facet_wrap(vars(Year)) +
  ylab("Ratio of mortality rates, reference Year 1946") +
  labs(colour="Year", linetype="Year") +
  scale_colour_brewer()
```
```{r}
(q  %+%
  ratio_mortality_rates(data_m_nl) +
  ggtitle("Variation of mortality quotient with respect to Y=1946, Males in Netherlands")) %>%
  ggplotly()
```
```{r}
(q  %+%
  ratio_mortality_rates(data_f_nl) +
  ggtitle("Variation of mortality quotient with respect to Y=1913, Women in Netherlands")) %>% ggplotly()
```


  1. Handle both genders and countries `Spain`, `Italy`, `France`, `England & Wales`, `USA`, `Sweden`, `Netherlands`.
  1. One properly facetted plot is enough.
  
```{r}
(q  %+%
  ratio_mortality_rates(data_b_nl) +
   facet_grid(vars(Country),vars(Year)) +
  ggtitle("Variation of mortality quotient with respect to Y=1946, both genders")) %>%
  ggplotly()
```
  

- [ ] Comment


# Trends


- [ ] Plot mortality quotients at ages $0, 1, 5$  as a function of time. Facet by Gender and Country

- [ ] Comment

- [ ] Plot mortality quotients at ages $15, 20, 40, 60$  as a function of time. Facet by `Gender` and `Country`

- [ ] Comment

# Rearrangement

- [ ] From dataframe `life_table`, compute another dataframe  called `life_table_pivot`
with primary key `Country`, `Gender` and `Year`, with a column for each `Age` from `0` up to `110`.
For each age column, the entry should be the central death rate
at the age defined by column, for `Country`, `Gender`  and `Year` identifying the row.

You may use functions `pivot_wider`, `pivot_longer` from `tidyr::` package.

The resulting schema should look like:

| Column Name | Type    |
|:------------|:--------|
| Country     | factor  |
| Gender      | factor  |
| Year        | integer |
| `0`         | double  |
| `1`         | double  |
| `2`         | double  |
| `3`         | double  |
| $\vdots$    | $\vdots$|

- [ ] Using `life_table_pivot` compute life expectancy at birth for each Country, Gender and Year

# Life expectancy

- [ ] Write a function that takes as input a vector of mortality quotients, as well as an age, and returns the residual life expectancy corresponding to the vector and the given age.

- [ ] Write a function that takes as input
a dataframe with the same schema as  `life_table` and returns
a data frame with columns `Country`, `Gender`, `Year`, `Age` defining a primary key
and a column `res_lex` containing _residual life expectancy_ corresponding to the pimary key.

In order to compute residual life expectancies, you may consider using `window` functions
oer apropriately defined windows. Package `dplyr` does not offer a rich API for window functions.
Package `dbplyr` does.

- [ ] Plot residual life expectancy as a function of `Year` at ages $60$ and $65$,
facet by `Gender` and `Country`.

```{r retirement, echo=FALSE, eval=FALSE}
```



# PCA  and SVD over log-mortality tables

- [ ] Pick a Country, a Gender,  a range of years `1948:2010`.
Extract the corresponding  lines from `life_table_pivot`. Take logarithms of
central death rates and perform principal component analysis.
- [ ] comment the screeplot
- [ ] comment the correlation circle
- [ ] comment the biplot

# Canonical Correlation Analysis

- [ ] Build a function that takes as input
  + a dataframe like `life_table_pivot`,
  + a couple  of countries, say `Spain` and `Sweeden`,
  + a vector of `Year`, say `1948:1998`
  + a `Gender` say `Female`
  returns a matrix called $Z$ with rows corresponding to `Year` and columns
  corresponding to couples `(Country, Age)`.

- [ ] Perform a Canonical Correspondance Analysis of $Z$
- [ ] Comment ...
- [ ] Comment ...

# Lee-Carter model for US mortality

During the last century, in the USA and in western Europe,
central death rates at all ages have exhibited a general decreasing trend.
This decreasing trend has not always been homogeneous across ages.

The Lee-Carter model has been designed to model and forecast the
evolution of the log-central death rates for the United States during the XXth century.

Let $A_{x,t}$ denote the log central death rate at age $x$ during year $t\in T$
for a given population (defined by Gender and Country).

The Lee-Carter model assumes that observed loagrithmic central death rates
are sampled according to the following model
\[
A_{x,t} \sim_{\text{independent}} a_x + b_x \kappa_t + \epsilon_{x,t}
\]
where $(a_x)_x, (b_x)_x$ and $(\kappa_t)_t$ are unknown vectors that satisfy
\[
a_x = \frac{1}{|T|}\sum_{t \in T} A_{x,t}\qquad \sum_{t\in T} \kappa_t = 0 \qquad \sum_{x} b_x^2 =1
\]
and $\epsilon_{x,t}$ are i.i.d Gaussian random variables.

## US data

- [ ] Fit a Lee-Carter model on the American data (for Male and Female data) training on years `1933` up to `1995`.
- [ ] Compare the fit provided by the Lee-Carter model with the fit provided by a rank $2$
truncated SVD
- [ ] Compare vectors avec $(a_x)_x, (b_x)_x$ and $(\kappa_t)_t$ with appropriate singular vectors.
- [ ] Use the Lee-Carter model to predict the central death rates for years $2000$ up to $2015$
- [ ] Plot predictions and observations for years $2000, 2005, 2010, 2015$

## Application of Lee-Carter model to a European Country

- [ ] Fit a Lee-Carter model to a European country
- [ ] Comment
- [ ] Compare with rank-2 truncated SVD
- [ ] Use the Lee-Carter model to predict the central death rates for years $2000$ up to $2015$
      Plot predictions and observations for years $2000, 2005, 2010, 2015$

## Predictions of life expectancies at different ages

- [ ] Use Lee-Carter approximation to approximate residual life expectations
- [ ] Compare with observed residual life expectations

# References

__Life tables and demography__

- [Human Mortality Database](https://www.mortality.org)
- [Tables de mortalité françaises, Jacques Vallin et France Meslé](https://www.lifetable.de/data/FRA/FRA000018061997CY1.pdf)
- [Modeling and Forecasting U.S. Mortality, R.D.Lee and L.R. Carter, JASA 1992]
- [Les dimensions de la mortalité, S. Ledermann, Jean Breas, Population, 1959]

__Graphics and reporting__

- [Interactive web-based data visualization with R, plotly, and shiny](https://plotly-r.com/index.html)
- [R for Data Science](https://r4ds.had.co.nz)
- [Layered graphics](http://vita.had.co.nz/papers/layered-grammar.pdf)
- [Plotly](http://plotly.com/)

__Tidyverse__

- [tidyselect](https://tidyselect.r-lib.org/articles/tidyselect.html)
- [dbplyr](https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html)
- [data.table](https://github.com/Rdatatable/data.table)
- [DT](https://rstudio.github.io/DT/)

__PCA, SVD, CCA__

- [FactoMineR](http://factominer.free.fr/index_fr.html)
- [ade4](http://pbil.univ-lyon1.fr/ade4/accueil.php)
- [FactoInvestigate](http://factominer.free.fr/reporting/index_fr.html)
- [PCA and Tidyverse](https://cmdlinetips.com/2019/05/how-to-do-pca-in-tidyverse-framework/)
- [tidyprcomp](https://broom.tidyverse.org/reference/tidy.prcomp.html)
